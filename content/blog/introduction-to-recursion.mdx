---
title: Introducci√≥n a la recursi√≥n
description: Aprende un poco sobre la recursividad para que puedas aprender acerca de la recursividad
image: /images/blog/recursion.webp
date: "2023-09-29"
author: jeremiasarriondo
categories:
  - Programming
---

La **recursi√≥n** o **recursividad** es la forma en la cual se especifica un proceso basado en su propia definici√≥n.

Para algunos tipos de problemas es √∫til tener funciones que se llaman a s√≠ mismas. Una funci√≥n recursiva es una funci√≥n que se llama a s√≠ misma.

Las funciones recursivas se programan definiendo:

1. Caso Base: son casos simples. Si la funci√≥n es llamada con el caso base la funci√≥n simplemente devuelve un resultado concreto. Toda funci√≥n recursiva debe tener al menos un caso base que marque el punto en el que la recursi√≥n debe detenerse. Cuando se alcanza el caso base, la funci√≥n recursiva deja de llamarse a s√≠ misma y comienza a devolver resultados.
2. Caso Recursivo: la funci√≥n es llamada con un problema m√°s complejo. Para hacer factible la recursi√≥n, este √∫ltimo debe parecerse al problema original. El paso de recursi√≥n puede dar como resultado muchas llamadas recursivas a la funci√≥n con problemas m√°s sencillos que el original.

<Callout>
üí° A tener en cuenta: las llamadas recursivas se gestionan mediante una estructura de datos llamada ‚Äúpila de llamadas‚Äù o ‚Äúpila de ejecuci√≥n‚Äù. Cada vez que se llama a la funci√≥n recursiva, se coloca una nueva entrada en la pila. Cuando se alcanza el caso base, las llamadas comienzas a resolverse y las salidas se combinan en el orden inverso de c√≥mo se llamaron.

</Callout>

A fin de que la recursi√≥n en forma eventual se termine y no entre en un bucle infinito, es decir, nunca termine de ejecutarse, cada vez que la funci√≥n se llame a s√≠ misma debe ser sobre una versi√≥n ligeramente m√°s sencilla que el problema original. Esta secuencia de problemas m√°s peque√±os deben converger en el caso base.

## Ejemplo: Factorial del n√∫mero entero

El factorial de un entero no negativo, escrito `n!` y pronunciado factorial de n, es el producto:

`n*(n-1)*(n-2)* ‚Ä¶ 1`, con 1‚â†1 y 0‚â†1.

El factorial de un entero n√∫mero mayor o igual a 0 puede ser calculado en forma iterativa utilizando la estructura de control for:

```cpp
#include <stdio.h>

using namespace std;

int main() {
    int i, n, fact = 1;
    n = 4;
    for (i=1; i<=n; i++){
        fact = fact * i;
    }
    printf("El factorial del n√∫mero %d es %d", n, fact);
    return 0;
}
```

> Output: El factorial del n√∫mero 4 es 24

Una definici√≥n **recursiva** de la funci√≥n factorial se obtiene al observar la siguiente relaci√≥n: `n! = n*(n-1)!`, podemos observarlo en la siguiente imagen:

<Image
  src="/images/blog/factorial-example.webp"
  alt="Recursi√≥n de factorial de 4"
  width={1607}
  height={946}
/>

La definici√≥n de la funci√≥n recursiva correspondiente al factorial es la siguiente:

```cpp
#include <stdio.h>

using namespace std;

long factorial(long numero){
    if (numero <= 1) return 1;
    else return (numero * factorial(numero -1));
}

int main() {
    int n = 4;
    printf("El factorial del n√∫mero %d es %lu", n, factorial(4));
    return 0;
}
```

> Utilizo una variable de tipo long porque la funci√≥n factorial crece r√°pido. El tipo long es un entero que ocupa 4 bytes y se define en el intervalo: 2.147.483.648 a 2.147.483.647

En conclusi√≥n, la recursi√≥n es una poderosa t√©cnica de programaci√≥n que nos permite abordar problemas complejos dividi√©ndolos en problemas m√°s peque√±os y manejables. A trav√©s de la llamada recursiva a una funci√≥n desde s√≠ misma, podemos resolver tareas de manera elegante y eficiente.

<Callout>
  üí° Divide y vencer√°s: la recursi√≥n en un componente clave del enfoque ‚Äúdivide
  y vencer√°s‚Äù, que se utiliza para resolver problemas dividi√©ndolos en
  subproblemas m√°s peque√±os que son m√°s f√°ciles de resolver.
</Callout>

Sin embargo, es importante recordar que la recursi√≥n debe utilizarse con precauci√≥n, ya que un uso incorrecto puede llevar a problemas de desbordamiento de pila. Al comprender los conceptos b√°sicos de la recursi√≥n y practicar su implementaci√≥n, los programadores pueden agregar una herramienta valiosa a su caja de herramientas y abordar una amplia variedad de desaf√≠os de programaci√≥n de manera m√°s eficaz.
